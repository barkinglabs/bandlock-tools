<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bandlock Calculator</title>
    <style>
        :root { --primary: #005a9c; --bg: #f8f9fa; --dark: #212529; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--dark); max-width: 1000px; margin: 40px auto; padding: 0 20px; }
        .card { background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); padding: 30px; }
        h1 { margin-top: 0; color: var(--primary); font-size: 1.5rem; border-bottom: 2px solid #eee; padding-bottom: 15px; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        label { font-weight: bold; font-size: 0.9rem; }
        
        .band-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(55px, 1fr)); gap: 6px; margin-bottom: 25px; }
        .band-btn { padding: 8px 2px; border: 1px solid #dee2e6; background: #fff; cursor: pointer; border-radius: 4px; font-weight: 600; font-size: 0.85rem; transition: 0.2s; }
        .band-btn:hover { border-color: var(--primary); background: #f0f7ff; }
        .band-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        .presets { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 20px; }
        .preset-btn { padding: 6px 12px; font-size: 0.8rem; background: #e9ecef; border: none; border-radius: 20px; cursor: pointer; transition: 0.2s; }
        .preset-btn:hover { background: #dee2e6; }
        .preset-btn.active { background: var(--primary); color: white; box-shadow: 0 0 0 2px white, 0 0 0 4px var(--primary); }

        input[type="text"], textarea { width: 100%; padding: 12px; border: 2px solid #eee; border-radius: 8px; font-size: 1rem; margin-bottom: 25px; outline: none; box-sizing: border-box; }
        input[type="text"]:focus, textarea:focus { border-color: var(--primary); }
        textarea { height: 120px; resize: vertical; font-family: monospace; }

        .output-container { background: #212529; color: #00ff41; padding: 20px; border-radius: 8px; position: relative; }
        .output-label { color: #888; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 8px; display: block; }
        #commandOutput { font-family: monospace; font-size: 1.1rem; word-break: break-all; line-height: 1.4; }
        
        .actions { margin-top: 15px; display: flex; gap: 10px; }
        .btn { padding: 10px 20px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .btn-copy { background: #28a745; color: white; }
        .btn-copy:hover { background: #218838; }
        .btn-clear { background: #dc3545; color: white; }
    </style>
</head>
<body>

<div class="card">
    <h1>nRF9160 / nRF9161 Bandlock Calculator (88-bit)</h1>

    <div class="label-row">
        <label>Fi Carrier Presets:</label>
    </div>
    <div class="presets">
        <button class="preset-btn" onclick="applyPreset([2,4,12])">AT&T (US)</button>
        <button class="preset-btn" onclick="applyPreset([4,13])">Verizon (US)</button>
        <button class="preset-btn" onclick="applyPreset([2, 4, 12, 25, 66])">T-Mobile (US)</button>
        <button class="preset-btn" onclick="applyPreset([1,2,3,4,5,8,12,13,20,25,26,28,66,85])">International</button>
    </div>

    <div class="label-row"><label>Toggle LTE Bands:</label></div>
    <div id="bandGrid" class="band-grid"></div>

    <div class="label-row"><label>Comma Separated List:</label></div>
    <input type="text" id="manualInput" placeholder="Enter bands (e.g. 1, 2, 3...)" oninput="syncFromInput()">

    <div class="label-row"><label>Binary Bitmap (octal escape format):</label></div>
    <input type="text" id="bitmapInput" placeholder='e.g. \237\030\010\013\000\000\000\000\002\000\020' oninput="syncFromBitmap()">

    <div class="label-row"><label>Indexed Byte List (decimal):</label></div>
    <textarea id="indexedBytesInput" placeholder="0:159
1:24
2:8
3:11
4:0
5:0
6:0
7:0
8:2
9:0
10:16" oninput="syncFromIndexedBytes()"></textarea>

    <div class="output-container">
        <span class="output-label">Generated AT Command</span>
        <div id="commandOutput">AT%XBANDLOCK=1,"0"</div>
        <div class="actions">
            <button class="btn btn-copy" onclick="copyCommand()">Copy Command</button>
            <button class="btn btn-clear" onclick="clearAll()">Clear All</button>
        </div>
    </div>
</div>

<script>
    const MAX_BANDS = 88;
    const grid = document.getElementById('bandGrid');
    const input = document.getElementById('manualInput');
    const output = document.getElementById('commandOutput');
    let selected = new Set();

    const PRESETS = [
        { bands: [2, 4, 12] },
        { bands: [4, 13] },
        { bands: [2, 4, 12, 25, 66] },
        { bands: [1, 2, 3, 4, 5, 8, 12, 13, 20, 25, 26, 28, 66, 85] }
    ];

    function setsMatch(currentSet, presetBands, presetBandsLength) {
        if (currentSet.size !== presetBandsLength) {
            return false;
        }
        for (let i = 0; i < presetBandsLength; i++) {
            if (currentSet.has(presetBands[i]) === false) {
                return false;
            }
        }
        return true;
    }

    // Init Grid
    for (let i = 1; i <= MAX_BANDS; i++) {
        const b = document.createElement('button');
        b.className = 'band-btn';
        b.innerText = i;
        b.id = `b-${i}`;
        b.onclick = () => toggleBand(i);
        grid.appendChild(b);
    }

    function toggleBand(num) {
        selected.has(num) ? selected.delete(num) : selected.add(num);
        update();
    }

    function applyPreset(bands) {
        selected = new Set(bands);
        update();
    }

    function syncFromInput() {
        const val = input.value.split(',').map(v => parseInt(v.trim())).filter(n => !isNaN(n) && n > 0 && n <= MAX_BANDS);
        selected = new Set(val);
        update(false);
    }

    function clearAll() {
        selected.clear();
        update();
    }

    function parseOctalBitmap(str, str_len) {
        const bytes = [];
        let i = 0;
        while (i < str_len) {
            if (str[i] === '\\' && i + 1 < str_len) {
                let octalStr = '';
                let j = i + 1;
                while (j < str_len && j < i + 4 && str[j] >= '0' && str[j] <= '7') {
                    octalStr = octalStr + str[j];
                    j++;
                }
                if (octalStr.length > 0) {
                    bytes.push(parseInt(octalStr, 8));
                    i = j;
                } else {
                    i++;
                }
            } else {
                bytes.push(str.charCodeAt(i));
                i++;
            }
        }
        return bytes;
    }

    function selectedToBytes(selectedSet, selectedSetSize, byteCount) {
        const bytes = new Array(byteCount).fill(0);
        if (selectedSetSize === 0) {
            return bytes;
        }
        selectedSet.forEach(function(bandNum) {
            const byteIndex = Math.floor((bandNum - 1) / 8);
            const bitPosition = (bandNum - 1) % 8;
            if (byteIndex >= 0 && byteIndex < byteCount) {
                bytes[byteIndex] = bytes[byteIndex] | (1 << bitPosition);
            }
        });
        return bytes;
    }

    function bytesToOctalBitmap(bytes, bytesLength) {
        let result = '';
        for (let i = 0; i < bytesLength; i++) {
            let octalStr = bytes[i].toString(8);
            while (octalStr.length < 3) {
                octalStr = '0' + octalStr;
            }
            result = result + '\\' + octalStr;
        }
        return result;
    }

    function bytesToIndexedByteList(bytes, bytesLength) {
        let result = '';
        for (let i = 0; i < bytesLength; i++) {
            if (i > 0) {
                result = result + '\n';
            }
            result = result + i.toString(10) + ':' + bytes[i].toString(10);
        }
        return result;
    }

    function syncFromBitmap() {
        const bitmapInput = document.getElementById('bitmapInput');
        let str = bitmapInput.value.trim();
        if (str.length >= 2 && str[0] === '"' && str[str.length - 1] === '"') {
            str = str.substring(1, str.length - 1);
        }
        const bytes = parseOctalBitmap(str, str.length);
        selected = new Set();
        for (let i = 0; i < bytes.length; i++) {
            for (let j = 0; j < 8; j++) {
                const bandNum = i * 8 + j + 1;
                if (bandNum > MAX_BANDS) {
                    break;
                }
                if ((bytes[i] & (1 << j)) !== 0) {
                    selected.add(bandNum);
                }
            }
        }
        update(true, false, true);
    }

    function parseIndexedBytes(str, str_len) {
        const bytes = new Array(11).fill(0);
        const lines = str.substring(0, str_len).split('\n');
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.length === 0) {
                continue;
            }
            const colonPos = line.indexOf(':');
            if (colonPos === -1) {
                continue;
            }
            const index = parseInt(line.substring(0, colonPos), 10);
            const value = parseInt(line.substring(colonPos + 1), 10);
            if (isNaN(index) === false && isNaN(value) === false && index >= 0 && index <= 10 && value >= 0 && value <= 255) {
                bytes[index] = value;
            }
        }
        return bytes;
    }

    function syncFromIndexedBytes() {
        const indexedInput = document.getElementById('indexedBytesInput');
        const str = indexedInput.value;
        const bytes = parseIndexedBytes(str, str.length);
        selected = new Set();
        for (let i = 0; i < bytes.length; i++) {
            for (let j = 0; j < 8; j++) {
                const bandNum = i * 8 + j + 1;
                if (bandNum > MAX_BANDS) {
                    break;
                }
                if ((bytes[i] & (1 << j)) !== 0) {
                    selected.add(bandNum);
                }
            }
        }
        update(true, true, false);
    }

    function update(updateText = true, updateBitmap = true, updateIndexedBytes = true) {
        // Update Buttons
        document.querySelectorAll('.band-btn').forEach(btn => {
            const id = parseInt(btn.innerText);
            btn.classList.toggle('active', selected.has(id));
        });

        // Update Preset Buttons
        const presetButtons = document.querySelectorAll('.preset-btn');
        for (let i = 0; i < presetButtons.length; i++) {
            const isMatch = setsMatch(selected, PRESETS[i].bands, PRESETS[i].bands.length);
            if (isMatch === true) {
                presetButtons[i].classList.add('active');
            } else {
                presetButtons[i].classList.remove('active');
            }
        }

        // Update Text Input
        if (updateText) {
            input.value = Array.from(selected).sort((a,b) => a-b).join(', ');
        }

        // Update Bitmap and Indexed Bytes Inputs
        const BYTE_COUNT = 11;
        const bytes = selectedToBytes(selected, selected.size, BYTE_COUNT);

        if (updateBitmap) {
            if (selected.size === 0) {
                document.getElementById('bitmapInput').value = '';
            } else {
                document.getElementById('bitmapInput').value = bytesToOctalBitmap(bytes, BYTE_COUNT);
            }
        }

        if (updateIndexedBytes) {
            if (selected.size === 0) {
                document.getElementById('indexedBytesInput').value = '';
            } else {
                document.getElementById('indexedBytesInput').value = bytesToIndexedByteList(bytes, BYTE_COUNT);
            }
        }

        // Generate Bitmap
        if (selected.size === 0) {
            output.innerText = 'AT%XBANDLOCK=1,"0"';
            return;
        }

        let bits = new Array(MAX_BANDS).fill(0);
        selected.forEach(b => bits[b-1] = 1);
        const bitString = bits.reverse().join('').replace(/^0+(?!$)/, ''); // Remove leading zeros
        output.innerText = `AT%XBANDLOCK=1,"${bitString}"`;
    }

    function copyCommand() {
        navigator.clipboard.writeText(output.innerText);
        alert("Command copied to clipboard!");
    }
</script>

</body>
</html>